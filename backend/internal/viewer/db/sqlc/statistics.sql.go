// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: statistics.sql

package sqlc

import (
	"context"
	"database/sql"
)

const getPeriodStatistics = `-- name: GetPeriodStatistics :many
SELECT
  title,
  SUM(EXTRACT(EPOCH FROM (finished_at - started_at)))::bigint as duration
FROM videos
WHERE
  ($1::timestamp IS NULL OR started_at >= $1::timestamp)
  AND ($2::timestamp IS NULL OR started_at < $2::timestamp)
GROUP BY title
ORDER BY duration DESC
LIMIT $3
`

type GetPeriodStatisticsParams struct {
	PeriodStart sql.NullTime `json:"period_start"`
	PeriodEnd   sql.NullTime `json:"period_end"`
	LimitCount  int32        `json:"limit_count"`
}

type GetPeriodStatisticsRow struct {
	Title    string `json:"title"`
	Duration int64  `json:"duration"`
}

func (q *Queries) GetPeriodStatistics(ctx context.Context, arg GetPeriodStatisticsParams) ([]GetPeriodStatisticsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPeriodStatistics, arg.PeriodStart, arg.PeriodEnd, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPeriodStatisticsRow{}
	for rows.Next() {
		var i GetPeriodStatisticsRow
		if err := rows.Scan(&i.Title, &i.Duration); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
